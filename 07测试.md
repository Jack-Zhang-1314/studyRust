# rust

## 测试

> 测试:预测代码是否和预期一样

* 测试函数体(通常)执行的3个操作
  * 准备数据/状态.
  * 运行被测试代码.
  * 断言(Assert)结果

>测试函数需要使用test属性(attribute)进行标注

* Attribute是一段Rust代码的元数据.在函数上加`#[test]`,可以把函数变成测试函数
* 使用`cargo test`运行所有测试函数.rust会构建一个`Test Runner`可执行行文件
  * 他会运行标注了test的函数,并报告器是否运行成功
* 放使用`cargo`创建library项目的时候,会生成一个test module.里面有一个test函数,可以添加任意数量的`test module`或函数

1. 创建lib项目`cargo new adder --lib`

   ```rs
   #[cfg(test)]
   mod tests {
       #[test]
       fn it_works() {
           let result = 2 + 2;
           assert_eq!(result, 4);
       }
   }
   ```

2. 运行`cargo test`,成功会显示`ok`,测试函数`panic`就表示失败
   * 每个测试运行在一个新线程,当主线程看见某个测试线程挂掉,就标记为失败

### 断言

>使用`assert!`宏来检查测试的结果

* `assert!`宏来自标准库,用来确定某个状态是否为true.
  * 如果是true.测试通过
  * 如果是false.调用panic,测试失败

1. `assert_eq!`:判断两个参数相等
2. `assert_ne!`:判断两个参数不相等
3. 如果断言失败,会打印出两个参数的值.然而使用`==`和`!=`不会这样
4. 使用debug格式打印参数.要求参数实现了`PartialEq`和`Debug Traits`(所有的基本类型以及绝大多数标准库大部分类型都实现了)

```rs
pub fn add_two(a: i32) -> i32 {
    a + 2
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn larger_can_hold_smaller() {
      //位置没有顺序
        assert_eq!(4, add_two(2))
    }
}
```

> 添加自定义错误信息

1. `assert!`:第一个参数必填,自定义消息作为第二个参数
2. `assert_eq!`和`assert_ne!`:前2个参数必填.自定义消息作为第三个参数
3. 自定义消息参数会被传递给`format!`宏,可以使用`{}`占位符

```rs
pub fn greeting() -> String {
    format!("Hello !")
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn greetings_contain_name() {
        let result = greeting();
        assert!(
            result.contains("cargo"),
            "Greeting did not contain name'{}'",
            result
        );
    }
}
```

>验证错误处理的情况

1. 测试除了验证代码的返回值是否正确,还需要验证大妈是否如预期的处理了发生错误的情况
2. 可验证代码在特定的情况下是否发生了`panic`

* `should_panic`(attribute):如果函数`panic`,函数就会测试通过;如果函数没有`panic`,测试失败
* `should_panic`更精确,可以为`should_panic`属性添加一个可选的`expected`参数
  * 将检查失败消息中是否包含所指定的文字.如果是我们所指定期待的恐慌,那么测试通过.如果不是,那么测试失败

```rs
pub struct Guess {
    value: u32,
}
impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1 {}.", value);
        } else if value > 100 {
            panic!("Guess value must be less than or equal to 100 {}.", value);
        }
        Guess { value }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    //只有超100的panic才会通过,小于1的测试不会通过,就算是符合1-100的也不会通过
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_new() {
        Guess::new(0);
    }
}
```

> 在测试中使用`Result<T,E>`

* 无需`panic`,可以使用`Result<T,E>`,返回类型编写测试.如果返回Ok,测试通过.如果返回Err,测试失败

```rs
#[cfg(test)]

mod tests {
  #[test]
  fn it_works() -> Result<(), String> {
    if 2 + 2 == 5 {
      Ok(())
    } else {
      Err(String::from("2+2 != 4"))
    }
  }
}
```

* 注意:不要在使用`Result<T,E>`编写的测试上标注`#[should_panic]`.因为运行失败直接返回Err

### 控制测试如何运行

> 改变cargo test的行为,添加命令行参数

* 默认行为:并行运行,所有测试,捕获(不显示)所有输出,使读取和测试结果相关的输出更容易

* 命令行参数:紧跟`cargo test`之后
  * `cargo test --help`:显示cargo test之后可用的命令参数
* 针对测试可执行程序:放在`--`之后
  * `cargo test -- --help`:显示`--`之后可用的参数有哪些

>并行/连续运行测试

1. 并行运行测试:默认使用多个线程并行运行(运行快)
   * 确保测试之间不会相互依赖.不依赖于某个共享状态(环境,工作目录,环境变量等等)
2. `--test-threads`:后边接线程的数量`cargo test -- --test-threads=1`
   * 传递给二进制文件
   * 不以并行的方式运行,或者想对线程数量进行细粒度的控制.

>显示函数输出

* 默认,如果测试通过,rust的tet库会捕获所有打印到标准输出流
* 例如:如果被测试大妈中使用到`println`:
  * 如果测试通过:不会在终端看到`println!`打印的内容
  * 如果测试失败:会看到`println!`打印的内容和失败信息

* 如果在成功的测试中看到打印内容`--show-output`
